Estructura del directorio: C:\Users\Javier\OneDrive\Documentos\GitHub\Tarea4Datos2

Tarea4Datos2
├── .gitattributes
├── .gitignore
├── CompresorUniversal
│   ├── Algoritmos
│   │   ├── AlgoritmoHuffman.cs
│   │   ├── AlgoritmoLZ77.cs
│   │   ├── AlgoritmoLZ78.cs
│   ├── Compresor.cs
│   ├── CompresorUniversal.csproj
│   ├── CompresorUniversal.csproj.user
│   ├── CompresorUniversal.sln
│   ├── FormPrincipal.cs
│   ├── FormPrincipal.resx
│   ├── Program.cs
├── LICENSE
├── ProyectoCompleto.txt
├── README.md

================================================================================
CONTENIDO DE ARCHIVOS
================================================================================

CompresorUniversal\Algoritmos\AlgoritmoHuffman.cs:
--------------------------------------------------
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CompresorUniversal.Algoritmos
{
    // *Implementación del algoritmo de Huffman*
    // Se implementa utilizando el algoritmo que se explica en el libro:
    // contar frecuencias, armar un árbol donde los símbolos más
    // comunes queden con códigos más cortos
    // y luego usar ese árbol para convertir los datos a bits.
    public class AlgoritmoHuffman
    {
        // Nodo del árbol de Huffman.
        // Si "Simbolo" es null quiere decir que es un nodo interno del árbol.
        //inicialización de la clase NodoHuffman.
        private class NodoHuffman
        {
            public byte? Simbolo { get; set; }// Símbolo si es hoja
            public int Frecuencia { get; set; } // cuántas veces aparece
            public NodoHuffman Izquierdo { get; set; }
            public NodoHuffman Derecho { get; set; }

            public bool EsHoja => Izquierdo == null && Derecho == null; 
        }

        // Compresión
        public byte[] Comprimir(byte[] datos)
        {
            if (datos == null || datos.Length == 0)
                return new byte[0]; // Caso vacío

            // 1) Contar cuántas veces aparece cada byte.
            var frecuencias = new Dictionary<byte, int>();
            foreach (byte b in datos)
            {
                if (!frecuencias.ContainsKey(b))
                    frecuencias[b] = 0;  // inicializar
                frecuencias[b]++;   // contar
            }

            // 2) Crear un nodo por símbolo y ordenarlos por frecuencia.
            // el libro lo hace con cola de prioridad, aquí se usa una lista.
            var nodos = new List<NodoHuffman>();
            foreach (var par in frecuencias)
                nodos.Add(new NodoHuffman { Simbolo = par.Key, Frecuencia = par.Value });
            nodos.Sort((a, b) => a.Frecuencia.CompareTo(b.Frecuencia)); // ordenar por frecuencia

            // 3) Armar el árbol juntando siempre los dos nodos menos frecuentes
            while (nodos.Count > 1)
            {
                var n1 = nodos[0];
                var n2 = nodos[1];
                nodos.RemoveAt(0);
                nodos.RemoveAt(0);

                var padre = new NodoHuffman
                {
                    Simbolo = null,      // nodo interno
                    Frecuencia = n1.Frecuencia+ n2.Frecuencia,
                    Izquierdo = n1,
                    Derecho = n2
                };

                //Insertar el nodo padre devolviéndolo a la lista ordenada
                int pos = nodos.FindIndex(n => n.Frecuencia >= padre.Frecuencia);
                if (pos >= 0)
                    nodos.Insert(pos, padre); // se inserta
                else
                    nodos.Add(padre);  // va al final
            }

            var raiz = nodos[0]; // el árbol final

            // 4) Recorrer el árbol y asignar códigos booleanos:izquierda=0, derecha=1
            var codigos = new Dictionary<byte,List<bool>>();

            GenerarCodigos(raiz, new List<bool>(), codigos);


            // 5) Reemplazar cada byte del archivo con su código binario.  
            var bitsComprimidos = CodificarDatos(datos, codigos);


            // 6) Guardar árbol y datos en un solo arreglo de bytes
            return SerializarResultado(raiz, bitsComprimidos, datos.Length);


        }

        // Descompresión: Para la descompresión simplemente consiste en hacer lo contrario de la compresión.
        public byte[] Descomprimir(byte[] datosComprimidos, int tamañoOriginal)
        {
            if (datosComprimidos == null || datosComprimidos.Length == 0)
                return new byte[0];

            using (var ms = new MemoryStream(datosComprimidos))

            using (var reader = new BinaryReader(ms))
            {
                // leer info del árbol (cuántos bits tiene y cuántos bytes ocupa)
                int bitsArbol = reader.ReadInt32();
                int bytesArbol = reader.ReadInt32();



                var arbolBytes = reader.ReadBytes(bytesArbol);
                var arbolBits = ConvertirBytesABits(arbolBytes, bitsArbol);

                int pos = 0;
                var raiz = DeserializarArbol(arbolBits, ref pos); // se reconstruye el árbol

                // Revisar que el tamaño coincida
                int tamañoGuardado = reader.ReadInt32();
                if (tamañoGuardado != tamañoOriginal)
                    throw new InvalidDataException("El tamaño original no coincide.");

                // caso donde solo haya un símbolo en todo el archivo (caso de error)
                if (raiz.EsHoja)

                    return Enumerable.Repeat(raiz.Simbolo.Value, tamañoOriginal).ToArray();

                // Leer el resto de datos (los bits del mensaje comprimido)
                var datosBytes = reader.ReadBytes((int)(ms.Length - ms.Position)); 
                var datosBits = ConvertirBytesABits(datosBytes);

                var resultado = new List<byte>();
                var actual = raiz;

                // Recorrer el árbol según los bits.
                foreach (bool bit in datosBits)
                {
                    actual = bit ? actual.Derecho : actual.Izquierdo; // derecha = 1, izquierda = 0

                    if (actual.EsHoja)
                    {
                        resultado.Add(actual.Simbolo.Value);
                        actual = raiz;

                        if (resultado.Count == tamañoOriginal)
                            break;
                    }
                }

                return resultado.ToArray();
            }
        }

        // asignar códigos a cada simbolo recorriendo el árbol
        private void GenerarCodigos(NodoHuffman nodo, List<bool> codigo, Dictionary<byte, List<bool>> codigos)
        {
            if (nodo == null) return;

            if (nodo.EsHoja)
            {
                // se copia el código actual y se asocia al símbolo
                codigos[nodo.Simbolo.Value] = new List<bool>(codigo);
            }
            else
            {
                // izquierda = 0
                codigo.Add(false);
                GenerarCodigos(nodo.Izquierdo, codigo, codigos);
                codigo.RemoveAt(codigo.Count - 1);

                // derecha = 1
                codigo.Add(true);
                GenerarCodigos(nodo.Derecho, codigo, codigos);
                codigo.RemoveAt(codigo.Count - 1);
            }
        }

        // reemplazar cada byte original por su secuencia de bits
        private List<bool> CodificarDatos(byte[] datos, Dictionary<byte, List<bool>> codigos)
        {
            var bits = new List<bool>(); // lista acumulada.
            foreach (var b in datos)
                bits.AddRange(codigos[b]); // agregar código correspondiente
            return bits;
        }

        // Empaquetar árbol junto a los bits comprimidos en formato binario
        private byte[] SerializarResultado(NodoHuffman raiz, List<bool> bitsComprimidos, int tamañoOriginal)
        {
            var arbolBits = new List<bool>();
            SerializarArbol(raiz, arbolBits);

            var arbolBytes = ConvertirBitsABytes(arbolBits);

            using (var ms = new MemoryStream())
            using (var writer = new BinaryWriter(ms))
            {
                writer.Write(arbolBits.Count);
                writer.Write(arbolBytes.Length);
                writer.Write(arbolBytes);
                writer.Write(tamañoOriginal);

                writer.Write(ConvertirBitsABytes(bitsComprimidos));

                return ms.ToArray();
            }
        }

        // Guardar el árbol como bits
        private void SerializarArbol(NodoHuffman nodo, List<bool> bits)
        {
            if (nodo.EsHoja)
            {
                
                bits.Add(true); // 1 = hoja
                byte simbolo = nodo.Simbolo.Value;

                for (int i = 7; i >= 0; i--)
                    bits.Add(((simbolo >> i) & 1) == 1);
            }
            else
            {
                // 0 = nodo interno
                bits.Add(false);
                SerializarArbol(nodo.Izquierdo, bits);
                SerializarArbol(nodo.Derecho, bits);
            }
        }


        // Reconstruir el árbol leyendo los bits
        private NodoHuffman DeserializarArbol(List<bool> bits, ref int pos)
        {
            if (pos >= bits.Count)
                return null;

            bool esHoja = bits[pos++];

            if (esHoja)
            {
                byte simbolo = 0;

                for (int i = 0; i < 8; i++)


                    simbolo = (byte)((simbolo << 1) | (bits[pos++] ? 1 : 0)); // leer los 8 bits

                return new NodoHuffman { Simbolo = simbolo };
            }
            else
            {
                var nodo = new NodoHuffman();
                nodo.Izquierdo = DeserializarArbol(bits, ref pos);
                nodo.Derecho = DeserializarArbol(bits, ref pos);
                return nodo;
            }
        }

        // Método para pasar bits a bytes
        private byte[] ConvertirBitsABytes(List<bool> bits)
        {
            int n = (bits.Count + 7) / 8; // redondeo
            var bytes = new byte[n];
            int index = 0;

            for (int i = 0; i < n; i++)
            {
                byte b = 0;
                for (int j = 0; j < 8 && index < bits.Count; j++)
                {
                    if (bits[index])
                        b |= (byte)(1 << (7 - j)); // escribir bit correspondiente
                    index++;
                }
                bytes[i] = b;
            }
            return bytes;
        }



        // Método para pasar bytes a bits
        private List<bool> ConvertirBytesABits(byte[] bytes, int limiteBits = -1)
        {
            int total = (limiteBits >= 0) ? limiteBits : bytes.Length * 8;
            var lista = new List<bool>(total);

            foreach (byte b in bytes)
            {
                for (int i = 7; i >= 0; i--)
                {
                    if (lista.Count == total)
                        return lista;
                    lista.Add(((b >> i) & 1) == 1); // se extrae bit por bit
                }
            }

            return lista;
        }
    }
}


--------------------------------------------------

CompresorUniversal\Algoritmos\AlgoritmoLZ77.cs:
-----------------------------------------------
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CompresorUniversal.Algoritmos
{
    // Implementación del algoritmo de compresión LZ77
    // usar una ventana que mira hacia atrás
    // para encontrar cadenas repetidas y codificarlas como desplazamiento, longitud, siguienteByte.



    public class AlgoritmoLZ77
    {
        // Tamaño de la ventana de búsqueda: 4KB 
        private const int TAM_VENTANA = 4096;

        // Clase interna para representar una tripleta (desplazamiento, longitud, siguiente byte)
        private class Tripleta
        {
            public int Desplazamiento;
            public int Longitud;
            public byte SiguienteByte;

            public Tripleta(int desplazamiento, int longitud, byte siguienteByte)
            {
                Desplazamiento = desplazamiento;
                Longitud = longitud;
                SiguienteByte = siguienteByte; // byte literal que va después de la coincidencia.
            }

            public Tripleta() { }
        }





        // Método de compresión
        public byte[] Comprimir(byte[] datos)
        {
            if (datos == null || datos.Length == 0)
                return new byte[0];

            List<Tripleta> tripletas = new List<Tripleta>();
            int i = 0;
            // Recorrer todos los datos de entrada
            while (i < datos.Length)
            {
                int mejorDesplazamiento = 0;
                int mejorLongitud = 0;
                // La ventana mira hacia atrás desde i
                int inicioVentana = (i > TAM_VENTANA) ? i - TAM_VENTANA : 0;

                // Buscar hacia atrás la secuencia más larga que coincida con la posición actual
                for (int j = inicioVentana; j < i; j++)
                {
                    int longitud = 0;
                    // Comparar mientras haya coincidencia y no se salga del arreglo
                    while (i + longitud < datos.Length && datos[j + longitud] == datos[i + longitud])
                    {
                        longitud++;
                        if (i + longitud >= datos.Length) break; //para evitar salirse del array
                    }

                    //si se encuentra algo mejor, se guarda
                    if (longitud > mejorLongitud)
                    {
                        mejorLongitud = longitud;
                        mejorDesplazamiento = i - j;
                    }
                    // Si se encuentra una coincidencia que llega hasta el final de los datos, no se necesita buscar más
                    if (mejorLongitud == datos.Length - i)
                        break;
                }

                // Determinar el siguiente byte después de la secuencia coincidente
                if (mejorLongitud > 0 && i + mejorLongitud < datos.Length)
                {
                    byte siguienteByte = datos[i + mejorLongitud]; // byte literal
                    tripletas.Add(new Tripleta(mejorDesplazamiento, mejorLongitud, siguienteByte)); 
                    i += mejorLongitud + 1;
                }
                else
                {
                    // Si no hubo coincidencia (longitud 0) o la coincidencia llega hasta el final de los datos
                    tripletas.Add(new Tripleta(0, 0, datos[i]));
                    i += 1;
                }
            }

            // Serializar la lista de tripletas en bytes
            return SerializarTripletas(tripletas);
        }






        // Método de descompresión
        public byte[] Descomprimir(byte[] datosComprimidos, int tamañoOriginal)
        {
            if (datosComprimidos == null || datosComprimidos.Length == 0)
                return new byte[0];

            List<Tripleta> tripletas = DeserializarTripletas(datosComprimidos);
            List<byte> resultado = new List<byte>();

            foreach (Tripleta t in tripletas)


            {
                // Si hay una referencia atrás (desplazamiento y longitud mayor a 0), copiar los bytes indicados
                if (t.Desplazamiento > 0 && t.Longitud > 0)
                {
                    int inicioCopia = resultado.Count - t.Desplazamiento;
                    for (int k = 0; k < t.Longitud; k++)
                    {
                        resultado.Add(resultado[inicioCopia + k]);
                    }

                }

                // Agregar el siguiente byte literal
                resultado.Add(t.SiguienteByte);
            }

            // Verificar el tamaño original reconstruido
            if (resultado.Count != tamañoOriginal)
            {
                throw new InvalidDataException("El tamaño de los datos descomprimidos no coincide con el tamaño original.");
            }


            return resultado.ToArray();
        }





        // Serializa la lista de tripletas a un arreglo de bytes
        private byte[] SerializarTripletas(List<Tripleta> tripletas)
        {


            using (MemoryStream ms = new MemoryStream())
            using (BinaryWriter writer = new BinaryWriter(ms))
            {
                // Escribir el número de tripletas
                writer.Write(tripletas.Count);
                // Escribir cada tripleta: desplazamiento, longitud, carácter siguiente
                foreach (Tripleta t in tripletas)
                {
                    writer.Write(t.Desplazamiento);
                    writer.Write(t.Longitud);
                    writer.Write(t.SiguienteByte);
                }
                return ms.ToArray();
            }
        }





        // Deserializa un arreglo de bytes en una lista de tripletas
        private List<Tripleta> DeserializarTripletas(byte[] datos)
        {
            List<Tripleta> tripletas = new List<Tripleta>();
            using (MemoryStream ms = new MemoryStream(datos))
            using (BinaryReader reader = new BinaryReader(ms))
            {
                int numTripletas = reader.ReadInt32();
                for (int i = 0; i < numTripletas; i++)
                {
                    Tripleta t = new Tripleta();
                    t.Desplazamiento = reader.ReadInt32();
                    t.Longitud = reader.ReadInt32();
                    t.SiguienteByte = reader.ReadByte();
                    tripletas.Add(t); // se agrega la tripleta reconstruida
                }
            }
            return tripletas;
        }
    }
}


--------------------------------------------------

CompresorUniversal\Algoritmos\AlgoritmoLZ78.cs:
-----------------------------------------------
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CompresorUniversal.Algoritmos
{
    // Implementación del algoritmo de compresión LZ78
    // La idea general es mantener un diccionario de "frases"
    // y cada salida es (índicePrefijo, símboloNuevo). Esto va armando un diccionario creciente


    public class AlgoritmoLZ78
    {
        // Clase interna para representar una pareja (índice de prefijo, símbolo)
        private class Pareja
        {
            public int Prefijo; // índice en el diccionario
            public byte Simbolo; // byte que se agrega

            public Pareja(int prefijo, byte simbolo)
            {
                Prefijo = prefijo; // prefijo a usar en la nueva entrada
                Simbolo = simbolo; // símbolo que se añade
            }
        }





        // Nodo del trie usado internamente para el diccionario de LZ78
        private class NodoTrie
        {
            public int Indice; // índice asignado a esta frase
            public Dictionary<byte, NodoTrie> Hijos = new Dictionary<byte, NodoTrie>();

            public NodoTrie(int indice)
            {
                Indice = indice;
            }
        }






        // Método de compresión
        public byte[] Comprimir(byte[] datos)
        {
            if (datos == null || datos.Length == 0)
                return new byte[0];

            // Se usa un TRIE real donde cada nodo representa una frase
            // y tiene hijos etiquetados por byte
            List<Pareja> salida = new List<Pareja>();

            // Raíz del trie: índice 0 = secuencia vacía
            NodoTrie raiz = new NodoTrie(0);
            int siguienteIndice = 1;

            NodoTrie nodoActual = raiz;
            int indicePrefijo = 0;
            List<byte> bytesAcumulados = new List<byte>(); // Bytes acumulados en la secuencia actual

            // Recorrer cada byte en los datos de entrada
            foreach (byte b in datos)
            {
                // Existe ya el hijo con este símbolo desde la frase actual?
                if (nodoActual.Hijos.TryGetValue(b, out NodoTrie hijo))
                {
                    // Si la combinación ya existe en el diccionario, entonces se sigue
                    // extendiendo la frase actual
                    nodoActual = hijo;
                    indicePrefijo = hijo.Indice;
                    bytesAcumulados.Add(b);
                }
                else
                {
                    // Si no existe, se emite la pareja actual 
                    salida.Add(new Pareja(indicePrefijo, b));

                    // Crear nueva frase en el trie con un índice nuevo
                    NodoTrie nuevo = new NodoTrie(siguienteIndice++);
                    nodoActual.Hijos[b] = nuevo;

                    // Reiniciar el prefijo para la siguiente secuencia
                    nodoActual = raiz;
                    indicePrefijo = 0;
                    bytesAcumulados.Clear();
                }
            }

            // Si quedaron bytes acumulados (terminamos en medio de una secuencia),
            // los emitimos como parejas individuales desde la raíz
            if (bytesAcumulados.Count > 0)
            {
                foreach (byte b in bytesAcumulados)
                {
                    salida.Add(new Pareja(0, b));
                }
            }

            // Serializar la lista de parejas en bytes
            return SerializarParejas(salida);
        }






        // Método de descompresión
        public byte[] Descomprimir(byte[] datosComprimidos, int tamañoOriginal)
        {
            if (datosComprimidos == null || datosComprimidos.Length == 0)
                return new byte[0];

            using (MemoryStream ms = new MemoryStream(datosComprimidos))
            using (BinaryReader reader = new BinaryReader(ms))
            {
                int numParejas = reader.ReadInt32(); // cuántas parejas vienen serializadas

                // Lista para el diccionario de secuencias donde índice 0 = secuencia vacía
                List<List<byte>> diccionario = new List<List<byte>>();
                diccionario.Add(new List<byte>());

                List<byte> resultado = new List<byte>();

                // Recorrer cada pareja para reconstruir las frases originales
                for (int i = 0; i < numParejas; i++)
                {
                    int prefijo = reader.ReadUInt16(); // índice del diccionario (ahora es ushort)
                    byte simbolo = reader.ReadByte(); // byte a agregar

                    List<byte> nuevaSecuencia;
                    if (prefijo == 0)
                    {
                        // Si el prefijo es 0, la frase comienza desde cero
                        nuevaSecuencia = new List<byte>();
                    }
                    else
                    {
                        // Si no, copiamos la frase indicada por el prefijo
                        nuevaSecuencia = new List<byte>(diccionario[prefijo]);
                    }

                    // Agregar el símbolo a la secuencia
                    nuevaSecuencia.Add(simbolo);

                    // Añadir la secuencia al resultado de salida
                    resultado.AddRange(nuevaSecuencia);

                    // Agregar la nueva secuencia al diccionario
                    diccionario.Add(nuevaSecuencia);
                }

                // Verificar que el tamaño obtenido coincida con el tamaño original
                if (resultado.Count != tamañoOriginal)
                {

                    throw new InvalidDataException("El tamaño de los datos descomprimidos no coincide con el tamaño original.");

                }


                return resultado.ToArray();
            }
        }








        // Serializa la lista de parejas a un arreglo de bytes
        private byte[] SerializarParejas(List<Pareja> parejas)

        {

          
            using (MemoryStream ms = new MemoryStream())

            using (BinaryWriter writer = new BinaryWriter(ms))
            {

                // Se escribe el número de parejas
                writer.Write(parejas.Count);
                // para escribir cada pareja se uso el índice de prefijo (ushort) y símbolo (byte)
                foreach (Pareja p in parejas)
                {

                    writer.Write((ushort)p.Prefijo); // índice del diccionario (2 bytes en lugar de 4)
                    writer.Write(p.Simbolo); // símbolo que se añade (1 byte)

                }
                return ms.ToArray();
            }
        }
    }
}

--------------------------------------------------

CompresorUniversal\Compresor.cs:
--------------------------------
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CompresorUniversal.Algoritmos;




// Clase que se encarga de generar y leer archivos .myzip.
namespace CompresorUniversal
{
    
    public class Compresor
    {
        private static readonly byte[] MAGIC = Encoding.ASCII.GetBytes("MYZIP");   // firma de formato

        private const byte CODIGO_HUFFMAN = 1;   // Huffman.
        private const byte CODIGO_LZ77 = 2;         //LZ77
        private const byte CODIGO_LZ78 = 3;   // LZ78






        // Método que recibe varias rutas y genera un único archivo comprimido.
        // El archivo .myzip contiene metadatos básicos y los bytes comprimidos..
        public void ComprimirArchivos(List<string> rutasArchivos, string archivoSalida,
            string algoritmo, out long totalOriginal, out long totalComprimido)

        {
            totalOriginal = 0;

            totalComprimido = 0;

            byte codigoAlgoritmo = ObtenerCodigoAlgoritmo(algoritmo);  // convertir nombre a número.

            using (FileStream fs = new FileStream(archivoSalida, FileMode.Create))
            using (BinaryWriter writer = new BinaryWriter(fs))



            {

                // Cabecera del archivo.
                writer.Write(MAGIC);
                writer.Write(codigoAlgoritmo);

                writer.Write(rutasArchivos.Count);

                foreach (string ruta in rutasArchivos)
                {
                    byte[] datosOriginales = File.ReadAllBytes(ruta);

                    totalOriginal += datosOriginales.Length;     // acumula tamaño original

                    // Comprimir usando el algoritmo elegido por el usuario (desde la UI).
                    byte[] datosComprimidos = ComprimirDatos(datosOriginales, algoritmo);

                    totalComprimido += datosComprimidos.Length;


                    string nombreArchivo = Path.GetFileName(ruta);    // sólo el nombre, sin ruta.

                    writer.Write(nombreArchivo);              // nombre del archivo dentro del paquete
                    writer.Write(datosOriginales.Length);     // tamaño original
                    writer.Write(datosComprimidos.Length);    // tamaño comprimido
                    writer.Write(datosComprimidos);           // bytes comprimidos reales.
                }
            }
        }








        // Descomprime un archivo .myzip completo y lo deja en una carpeta destino.
        // retorna estadísticas para la UI (tamaños y algoritmo).
        public void DescomprimirArchivos(string archivoEntrada, string carpetaSalida,
            out long totalOriginal, out long totalComprimido, out string algoritmoUsado)
        {
            totalOriginal = 0;
            totalComprimido = 0;

            using (FileStream fs = new FileStream(archivoEntrada, FileMode.Open))
            using (BinaryReader reader = new BinaryReader(fs))
            {
                // Leer la firma del archivo. Si no coincide, el archivo no es válido..
                byte[] magic = reader.ReadBytes(MAGIC.Length);
                if (!magic.SequenceEqual(MAGIC))
                {
                    throw new Exception("El archivo no es un .myzip válido");    // error
                }

                // El archivo guarda el número del algoritmo, no el nombre.
                byte codigoAlgoritmo = reader.ReadByte();
                algoritmoUsado = ObtenerNombreAlgoritmo(codigoAlgoritmo);

                int numArchivos = reader.ReadInt32();  // cuántos archivos contiene el .myzip

                for (int i = 0; i < numArchivos; i++)
                {
                    string nombreArchivo = reader.ReadString();           // nombre original
                    int tamañoOriginal = reader.ReadInt32();              // guardado en cabecera
                    int tamañoComprimido = reader.ReadInt32();
                    byte[] datosComprimidos = reader.ReadBytes(tamañoComprimido);

                    totalOriginal += tamañoOriginal;
                    totalComprimido += tamañoComprimido;

                    // Descomprimir según el algoritmo registrado.
                    byte[] datosOriginales = DescomprimirDatos(datosComprimidos,
                        tamañoOriginal, algoritmoUsado);

                    // Guardar el archivo restaurado en la carpeta de salida.
                    string rutaSalida = Path.Combine(carpetaSalida, nombreArchivo);
                    File.WriteAllBytes(rutaSalida, datosOriginales);   // se escribe en disco
                }
            }
        }








        // Recibe los datos y delega la compresión al algoritmo correcto.
        private byte[] ComprimirDatos(byte[] datos, string algoritmo)
        {
            switch (algoritmo)
            {
                case "Huffman":

                    AlgoritmoHuffman h = new AlgoritmoHuffman();

                    return h.Comprimir(datos);  

                case "LZ77":
                    AlgoritmoLZ77 lz77 = new AlgoritmoLZ77();

                    return lz77.Comprimir(datos);

                case "LZ78":

                    AlgoritmoLZ78 lz78 = new AlgoritmoLZ78();

                    return lz78.Comprimir(datos);

                default:


                    throw new Exception("Algoritmo no reconocido: " + algoritmo);
            }


        }








        // Hace lo opuesto: recibe bytes comprimidos y usa el algoritmo indicado para restaurarlos.
        // tamañoOriginal sirve para validación y para saber cuándo parar.
        private byte[] DescomprimirDatos(byte[] datosComprimidos, int tamañoOriginal, string algoritmo)
        {
            switch (algoritmo)
            {
                case "Huffman":
                    AlgoritmoHuffman h = new AlgoritmoHuffman();
                    return h.Descomprimir(datosComprimidos, tamañoOriginal);

                case "LZ77":
                    AlgoritmoLZ77 lz77 = new AlgoritmoLZ77();
                    return lz77.Descomprimir(datosComprimidos, tamañoOriginal);

                case "LZ78":
                    AlgoritmoLZ78 lz78 = new AlgoritmoLZ78();
                    return lz78.Descomprimir(datosComprimidos, tamañoOriginal);

                default:
                    throw new Exception("Algoritmo no reconocido: " + algoritmo);   // caso imposible desde UI
            }
        }








        // Recibe un nombre de algoritmo y lo convierte a un código numérico
        // que se guarda en la cabecera del archivo.
        private byte ObtenerCodigoAlgoritmo(string algoritmo)
        {
            switch (algoritmo)
            {
                case "Huffman": return CODIGO_HUFFMAN;
                case "LZ77": return CODIGO_LZ77;
                case "LZ78": return CODIGO_LZ78;
                default:
                    throw new Exception("Algoritmo desconocido: " + algoritmo);
            }
        }








        // Conversión inversa:  convierte código → nombre.
        // Útil cuando se lee la cabecera de un .myzip.
        private string ObtenerNombreAlgoritmo(byte codigo)
        {
            switch (codigo)
            {
                case CODIGO_HUFFMAN: return "Huffman";    // normal.
                case CODIGO_LZ77: return "LZ77";
                case CODIGO_LZ78: return "LZ78";
                default:
                    throw new Exception("Código de algoritmo desconocido: " + codigo);
            }
        }
    }
}


--------------------------------------------------

CompresorUniversal\CompresorUniversal.csproj:
---------------------------------------------
﻿<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
    <EnableWindowsTargeting>true</EnableWindowsTargeting>
    <Nullable>enable</Nullable>
    <ApplicationIcon />
    <StartupObject>CompresorUniversal.Program</StartupObject>
  </PropertyGroup>

</Project>


--------------------------------------------------

CompresorUniversal\CompresorUniversal.sln:
------------------------------------------
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.10.35122.118
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CompresorUniversal", "CompresorUniversal.csproj", "{62CA7D1B-B63F-4C2A-A286-710ACCE9302D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{62CA7D1B-B63F-4C2A-A286-710ACCE9302D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{62CA7D1B-B63F-4C2A-A286-710ACCE9302D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{62CA7D1B-B63F-4C2A-A286-710ACCE9302D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{62CA7D1B-B63F-4C2A-A286-710ACCE9302D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {04319661-92A7-40F1-A114-260221FFE9B7}
	EndGlobalSection
EndGlobal


--------------------------------------------------

CompresorUniversal\FormPrincipal.cs:
------------------------------------
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Windows.Forms;




namespace CompresorUniversal

{
    public partial class FormPrincipal : Form
    {
        private List<string> archivosSeleccionados;

        private ListBox listBoxArchivos;
        private ComboBox comboAlgoritmo;
        private Button btnComprimir;
        private Button btnDescomprimir;
        private Label lblTiempo;
        private Label lblMemoria;
        private Label lblTasa;


        public FormPrincipal()
        {
            archivosSeleccionados = new List<string>();
            InitializeComponent();
        }



        private void InitializeComponent()
        {
            // título de la ventana
            this.Text = "Compresor Universal";
            this.Size = new Size(510, 460);   
            StartPosition = FormStartPosition.CenterScreen;
            this.MaximizeBox = false;        
            this.BackColor = SystemColors.Control; 

            int y = 18;  


            
            

            Label lblArchivos = new Label();
            lblArchivos.Text = "Archivos a comprimir:";
            lblArchivos.Location = new Point(20, y);
            lblArchivos.AutoSize = true;
            this.Controls.Add(lblArchivos);

            y += 23;

            //listbox con los archivos 
            listBoxArchivos = new ListBox();
            listBoxArchivos.Location = new Point(20, y);
            listBoxArchivos.Size = new Size(445, 95);
            Controls.Add(listBoxArchivos);

            y += 105;

            Button btnAgregar = new Button();
            btnAgregar.Text = "Agregar archivos...";
            btnAgregar.Location = new Point(20, y);
            btnAgregar.Size = new Size(135, 29);   
            btnAgregar.Click += BtnAgregar_Click;
            this.Controls.Add(btnAgregar);

            Button btnLimpiar = new Button();
            btnLimpiar.Text = "Limpiar lista";
            btnLimpiar.Location = new Point(165, y + 1);  
            btnLimpiar.Size = new Size(95, 28);
            btnLimpiar.Click += BtnLimpiar_Click;
            Controls.Add(btnLimpiar);

            y += 42;

            Label lblAlgoritmo = new Label();
            lblAlgoritmo.Text = "Algoritmo:";
            lblAlgoritmo.Location = new Point(20, y);
            lblAlgoritmo.AutoSize = true;
            Controls.Add(lblAlgoritmo);

            // label 
            Label lblNotaAlg = new Label();
            lblNotaAlg.Text = "(Huffman / LZ77 / LZ78)";
            lblNotaAlg.Location = new Point(90, y + 1);
            lblNotaAlg.AutoSize = true;
            lblNotaAlg.ForeColor = Color.DimGray;
            this.Controls.Add(lblNotaAlg);

            y += 24;

            comboAlgoritmo = new ComboBox();
            comboAlgoritmo.Location = new Point(20, y);
            comboAlgoritmo.Size = new Size(155, 23);
            comboAlgoritmo.DropDownStyle = ComboBoxStyle.DropDownList;
            comboAlgoritmo.Items.Add("Huffman");
            comboAlgoritmo.Items.Add("LZ77");
            comboAlgoritmo.Items.Add("LZ78");
            comboAlgoritmo.SelectedIndex = 0;  //huffman por defecto
            this.Controls.Add(comboAlgoritmo);

            y += 44;

            btnComprimir = new Button();
            btnComprimir.Text = "Comprimir";
            btnComprimir.Location = new Point(20, y);
            btnComprimir.Size = new Size(155, 38);
            btnComprimir.Click += BtnComprimir_Click;
            Controls.Add(btnComprimir);

            btnDescomprimir = new Button();
            btnDescomprimir.Text = "Descomprimir";
            btnDescomprimir.Location = new Point(190, y - 2);  
            btnDescomprimir.Size = new Size(155, 41);
            btnDescomprimir.Click += BtnDescomprimir_Click;
            this.Controls.Add(btnDescomprimir);

            y += 55;

            
            Label lblEstadisticas = new Label();
            lblEstadisticas.Text = "Estadísticas:";
            lblEstadisticas.Location = new Point(20, y);
            lblEstadisticas.AutoSize = true;
            Controls.Add(lblEstadisticas);

            y += 22;

            lblTiempo = new Label();
            lblTiempo.Text = "Tiempo: --";
            lblTiempo.Location = new Point(25, y);
            lblTiempo.AutoSize = true;
            this.Controls.Add(lblTiempo);

            y += 19;

            lblMemoria = new Label();
            lblMemoria.Text = "Memoria: --";
            lblMemoria.Location = new Point(25, y);
            lblMemoria.AutoSize = true;
            Controls.Add(lblMemoria);

            y += 19;

            lblTasa = new Label();
            lblTasa.Text = "Tasa de compresión: --";
            lblTasa.Location = new Point(25, y);
            lblTasa.AutoSize = true;
            this.Controls.Add(lblTasa);
        }



        private void BtnAgregar_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.Filter = "Archivos de texto (*.txt)|*.txt|Todos los archivos (*.*)|*.*";
            ofd.Multiselect = true;
            ofd.Title = "Seleccionar archivos";

            if (ofd.ShowDialog() == DialogResult.OK)
            {
                foreach (string archivo in ofd.FileNames)
                {
                    if (!archivosSeleccionados.Contains(archivo))
                    {
                        archivosSeleccionados.Add(archivo);
                        listBoxArchivos.Items.Add(Path.GetFileName(archivo));  //solo nombre
                    }
                }
            }
        }


        private void BtnLimpiar_Click(object sender, EventArgs e)
        {
            archivosSeleccionados.Clear();
            listBoxArchivos.Items.Clear();

            lblTiempo.Text = "Tiempo: --";
            lblMemoria.Text = "Memoria: --";
            lblTasa.Text = "Tasa de compresión: --";
        }



        private void BtnComprimir_Click(object sender, EventArgs e)
        {
            if (archivosSeleccionados.Count == 0)
            {
                MessageBox.Show("Seleccione al menos un archivo.","Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            string algoritmo = comboAlgoritmo.SelectedItem.ToString();

            SaveFileDialog sfd = new SaveFileDialog();
            sfd.Filter = "Archivo comprimido (*.myzip)|*.myzip";
            sfd.Title = "Guardar archivo comprimido";
            sfd.FileName = "archivo_comprimido.myzip";

            if (sfd.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    Stopwatch sw = Stopwatch.StartNew();

                    //se limpia memoria
                    GC.Collect();
                    GC.WaitForPendingFinalizers();
                    GC.Collect();
                    long memBefore = GC.GetTotalMemory(true);

                    Compresor compresor = new Compresor();
                    long totalOriginal, totalComprimido;

                    compresor.ComprimirArchivos(archivosSeleccionados, sfd.FileName, algoritmo,
                                                out totalOriginal, out totalComprimido);

                    sw.Stop();

                    GC.Collect();
                    GC.WaitForPendingFinalizers();
                    GC.Collect();
                    long memAfter = GC.GetTotalMemory(true);
                    long memUsada = Math.Max(0, memAfter - memBefore);

                    double ratio = (double)totalComprimido / totalOriginal * 100.0;

                    lblTiempo.Text = "Tiempo: " + sw.ElapsedMilliseconds + " ms";
                    lblMemoria.Text = "Memoria: " + (memUsada / 1024.0 / 1024.0).ToString("F2") + " MB";
                    lblTasa.Text = "Tasa de compresión: " + ratio.ToString("F2") + "%";

                    MessageBox.Show("Compresión completada.\n\nArchivo: " +Path.GetFileName(sfd.FileName) +
                                    "\nAlgoritmo: " + algoritmo +
                                    "\nTiempo: " + sw.ElapsedMilliseconds +" ms" +
                                    "\nTamaño original: " + totalOriginal.ToString("N0") + " bytes" +
                                    "\nTamaño comprimido: " + totalComprimido.ToString("N0") + " bytes" +
                                    "\nTasa: " + ratio.ToString("F2") + "%",
                                    "Compresión", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Error durante la compresión:\n\n" + ex.Message, "Error",
                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }



        private void BtnDescomprimir_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.Filter = "Archivo comprimido (*.myzip)|*.myzip";
            ofd.Title = "Seleccionar archivo .myzip";

            if (ofd.ShowDialog() == DialogResult.OK)
            {
                FolderBrowserDialog fbd = new FolderBrowserDialog();
                fbd.Description = "Seleccionar carpeta de destino";

                if (fbd.ShowDialog() == DialogResult.OK)


                {


                    try



                    {

                        Stopwatch sw = Stopwatch.StartNew();

                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        GC.Collect();
                        long memBefore = GC.GetTotalMemory(true);

                        Compresor compresor = new Compresor();
                        long totalOriginal, totalComprimido;
                        string algoritmoUsado;

                        compresor.DescomprimirArchivos(ofd.FileName, fbd.SelectedPath,
                                                       out totalOriginal, out totalComprimido,
                                                       out algoritmoUsado);

                        sw.Stop();

                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        GC.Collect();
                        long memAfter = GC.GetTotalMemory(true);
                        long memUsada = Math.Max(0, memAfter - memBefore);

                        double ratio = (double)totalComprimido / totalOriginal * 100.0;

                        lblTiempo.Text = "Tiempo: " + sw.ElapsedMilliseconds + " ms";
                        lblMemoria.Text = "Memoria: " + (memUsada / 1024.0 / 1024.0).ToString("F2") + " MB";
                        lblTasa.Text = "Tasa de compresión: " + ratio.ToString("F2") + "%";

                        MessageBox.Show("Descompresión completada.\n\nAlgoritmo usado: " + algoritmoUsado +
                                        "\nDestino: " + fbd.SelectedPath +
                                        "\nTiempo: " + sw.ElapsedMilliseconds + " ms",
                                        "Descompresión", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show("Error durante la descompresión:\n\n" + ex.Message, "Error",
                                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }
    }
}


--------------------------------------------------

CompresorUniversal\Program.cs:
------------------------------
using System;
using System.Windows.Forms;

namespace CompresorUniversal
{
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new FormPrincipal());
        }
    }
}

--------------------------------------------------

README.md:
----------
# Tarea4Datos2



--------------------------------------------------

